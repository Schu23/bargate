#!/usr/bin/python
#
# This file is part of Bargate.
#
# Bargate is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Bargate is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Bargate.  If not, see <http://www.gnu.org/licenses/>.

from bargate import app
import string, os, io, sys, stat, pprint, urllib, re, StringIO, glob, traceback, socket, tempfile
from flask import Flask, send_file, request, session, g, redirect, url_for, abort, flash, make_response, jsonify, render_template
import bargate.lib.core
import bargate.lib.errors
import bargate.lib.userdata
import bargate.lib.mime
import bargate.views.errors

from smb.SMBConnection import SMBConnection
from smb.base import SMBTimeout, NotReadyError, NotConnectedError, SharedDevice
from smb.smb_structs import UnsupportedFeature, ProtocolError, OperationFailure
from PIL import Image

import time
import uuid

class backend_pysmb:
	def smb_error(self,exception_object,uri="Unknown",redirect_to=None):
		"""Handles exceptions generated by pysmb functions. It currently deals with
		all known smb exceptions. This will generate fancy formatted messages
		for each smb type.
		"""

		# pysmb exceptions
		if isinstance(exception_object,SMBTimeout):
			return self._exSMBTimeout(redirect_to)
		if isinstance(exception_object,NotReadyError):
			return self._exNotReadyError(redirect_to)
		if isinstance(exception_object,NotConnectedError):
			return self._exNotConnectedError(redirect_to)
		if isinstance(exception_object,UnsupportedFeature):
			return self._exUnsupportedFeature(redirect_to)
		if isinstance(exception_object,ProtocolError):
			return self._exProtocolError(redirect_to)
		if isinstance(exception_object,OperationFailure):
			#return self._exOperationFailure(redirect_to)
			return bargate.views.errors.error500(exception_object)

		# anything else
		else:
			return bargate.views.errors.error500(exception_object)

################################################################################

	def smb_action(self,func_path,func_name,active=None,display_name="Home",action='browse',path=''):
		"""
			func_path       this is the full SMB path to the server, optionally 
			                including the share name, and any subsequent dirs
			                the user can't browse 'above' this path, and does
			                not get to see this path.

			func_name       a unique identifier for this 'view' or 'function'
			                that the user can select and use.

			active          what should the 'active' variable set to, for menu
			                highlights in HTML?

			display_name    the friendly name for this 'view' or 'function',
			                to use instead of the func_path. Defaults to "Home".

			action          the action the user is trying to perform

			path            the path the user is viewing, which is in addition
			                to the 'func_path'.

			example:
			    func_path        smb://server/users/username/
			    func_name        userfiles
			    active           userfiles
			    display_name     my files
			    action           browse
			    path             mydocuments/
		"""

		## default the 'active' variable to the function name
		if active == None:
			active = func_name

		## If the method is POST then 'action' is sent via a POST parameter 
		## rather than via a so-called "GET" parameter in the URL
		if request.method == 'POST':
			action = request.form['action']

		if func_path.endswith('/'):
			func_path = func_path[:-1]

		## func_path should always start with smb://
		if not func_path.startswith("smb://"):
			return bargate.lib.errors.stderr("Invalid server path",'The server URL must start with smb://')

		## work out just the server name part of the URL 
		func_path_parts   = func_path.replace("smb://","").split('/')
		server_name = func_path_parts[0]

		if len(func_path_parts) == 1:
			## there is no share in the func_path
			## so we have to either list shares, or take the share name out
			## of the path
			if len(path) == 0:
				# list shares
				share_name = None
			else:
				(share_name,seperator,path_without_share) = path.partition('/')
		else:
			share_name = func_path_parts[1]

			# is there multiple parts to the func_path, i.e., we've not been
			# given a share root?
			if len(func_path_parts) == 2:
				func_path_without_share = ""
			else:
				func_path_without_share = "/" + "/".join(func_path_parts[2:])

			if len(func_path_without_share) > 0:
				path_without_share = func_path_without_share + "/" + path
			else:
				path_without_share = path

		## Work out the 'entry name'
		if len(path) > 0:
			(a,b,entry_name) = path.rpartition('/')
		else:
			entry_name = ""

		## Check the path is not bad/dangerous
		try:
			bargate.lib.core.check_path(path)
		except ValueError as e:
			return bargate.lib.errors.invalid_path()

		## Connect to the SMB server
		conn = SMBConnection(session['username'], bargate.lib.user.get_password(), socket.gethostname(), server_name, domain=app.config['SMB_WORKGROUP'], use_ntlm_v2 = True, is_direct_tcp=True)

		if not conn.connect(server_name,port=445,timeout=5):
			return bargate.lib.errors.stderr("Could not connect","Could not connect to the file server, authentication was unsuccessful")

		app.logger.info('user: "' + session['username'] + '", func_path: "' + func_path + '", share_name: "' + unicode(share_name) + '", endpoint: "' + func_name + '", action: "' + action + '", method: ' + str(request.method) + ', path: "' + path + '", addr: "' + request.remote_addr + '", ua: ' + request.user_agent.string)

		if share_name is None:
			# there is no share name specified, so the only thing we can do here is browse
			if action == 'browse':
				if 'xhr' in request.args:

					try:
						smb_shares = conn.listShares()
					except Exception as ex:
						return self.smb_error(ex)

					shares = []
					for share in smb_shares:
						if share.type == SharedDevice.DISK_TREE:
							shares.append({'name': share.name, 'url': url_for(func_name,path=share.name)})

					## are there any items in the list?
					no_items = False
					if len(shares) == 0:
						no_items = True

					## Render the template
					return render_template('directory-grid.html',
						active=active,
						dirs=[], files=[], shares=shares, crumbs=[], path=path,
						url_home=url_for(func_name),
						url_bookmark=url_for('bookmarks'),
						url_search=url_for(func_name,path=path,action="search"),
						browse_mode=True,
						browse_butts_enabled=False,
						bmark_enabled=False,
						func_name = func_name,
						root_display_name = display_name,
						on_file_click=bargate.lib.userdata.get_on_file_click(),
						no_items = no_items,
					)
				else:
					return render_template('browse.html',url=url_for(func_name,path=path),browse_mode=True)
			else:
				abort(400)

		if request.method == 'GET':
			###############################
			# GET: DOWNLOAD OR 'VIEW' FILE
			###############################
			if action == 'download' or action == 'view':

				try:
					## Default to sending files as an 'attachment' ("Content-Disposition: attachment")
					attach = True

					try:
						sfile = conn.getAttributes(share_name,path_without_share)
					except Exception as ex:
						return bargate.lib.errors.stderr("Not found","The path you specified does not exist, or could not be read")

					## if we were asked to 'download' a directory, redirect to browse instead
					if sfile.isDirectory:
						return redirect(url_for(func_name,path=path))

					## guess a mimetype
					(ftype,mtype) = bargate.lib.mime.filename_to_mimetype(entry_name)

					## If the user requested to 'view' (don't download as an attachment) make sure we allow it for that filetype
					if action == 'view':
						if bargate.lib.mime.view_in_browser(mtype):
							attach = False

					## pysmb wants to write to a file, rather than provide a file-like object to read from. EUGH.
					## so we need to write to a temporary file that Flask's send_file can then read from.
					tfile = tempfile.SpooledTemporaryFile(max_size=1048576)

					## Read data into the tempfile via SMB
					conn.retrieveFile(share_name,path_without_share,tfile)
					## Seek back to 0 on the tempfile, otherwise send_file breaks (!)
					tfile.seek(0)

					## Send the file to the user
					resp = make_response(send_file(tfile,add_etags=False,as_attachment=attach,attachment_filename=entry_name,mimetype=mtype))
					resp.headers['Content-length'] = sfile.file_size
					return resp
	
				except Exception as ex:
					return self.smb_error(ex)

			####################
			# GET: IMAGE PREVIEW
			####################
			elif action == 'preview':
				if not app.config['IMAGE_PREVIEW']:
					abort(400)

				try:
					sfile = conn.getAttributes(share_name,path_without_share)
				except Exception as ex:
					abort(400)

				## ensure item is a file
				if sfile.isDirectory:
					abort(400)
			
				## guess a mimetype
				(ftype,mtype) = bargate.lib.mime.filename_to_mimetype(entry_name)
		
				## Check size is not too large for a preview
				if sfile.file_size > app.config['IMAGE_PREVIEW_MAX_SIZE']:
					abort(403)
			
				## Only preview files that Pillow supports
				if not mtype in bargate.lib.mime.pillow_supported:
					abort(400)

				## read the file
				tfile = tempfile.SpooledTemporaryFile(max_size=1048576)
				conn.retrieveFile(share_name,path_without_share,tfile)
				tfile.seek(0)

				try:
					pil_img = Image.open(tfile).convert('RGB')
					size = 200, 200
					pil_img.thumbnail(size, Image.ANTIALIAS)

					ifile = StringIO.StringIO()
					pil_img.save(ifile, 'JPEG', quality=85)
					ifile.seek(0)
					return send_file(ifile, mimetype='image/jpeg',add_etags=False)
				except Exception as ex:
					abort(400)

			################################################
			# GET: STAT FILE (ajax call to get more details)
			################################################
			elif action == 'stat': 

				try:
					sfile = conn.getAttributes(share_name,path_without_share)
				except Exception as ex:
					return jsonify({'error': 1, 'reason': 'An error occured: ' + str(type(ex)) + ": " + str(ex)})

				## ensure item is a file
				if sfile.isDirectory:
					return jsonify({'error': 1, 'reason': 'You cannot stat a directory!'})

				data = {}	
				data['filename']              = sfile.filename
				data['size']                  = sfile.file_size
				data['atime']                 = bargate.lib.core.ut_to_string(sfile.last_access_time)
				data['mtime']                 = bargate.lib.core.ut_to_string(sfile.last_write_time)
				(data['ftype'],data['mtype']) = bargate.lib.mime.filename_to_mimetype(data['filename'])
				data['owner']                 = "N/A"
				data['group']                 = "N/A"
				data['error']                 = 0

				try:
					secDesc = conn.getSecurity(share_name,path_without_share)

					if app.config['WBINFO_LOOKUP']:
						data['owner'] = bargate.lib.core.wb_sid_to_name(str(secDesc.owner))
						data['group'] = bargate.lib.core.wb_sid_to_name(str(secDesc.group))
					else:
						data['owner'] = str(secDesc.owner)
						data['group'] = str(secDesc.group)
				except Exception as ex:
					pass


				return jsonify(data)

			###############################
			# GET: BROWSE
			###############################
			elif action == 'browse':
				#### SEARCH
				if 'q' in request.args:

					if not app.config['SEARCH_ENABLED']:
						abort(404)

					## Build a breadcrumbs trail ##
					crumbs = []
					parts = path.split('/')
					b4 = ''

					## Build up a list of dicts, each dict representing a crumb
					for crumb in parts:
						if len(crumb) > 0:
							crumbs.append({'name': crumb, 'url': url_for(func_name,path=b4+crumb)})
							b4 = b4 + crumb + '/'

					query = request.args.get('q')
					self._init_search(conn,func_name,share_name,path,path_without_share,query)
					results, timeout_reached = self._search()

					#if timeout_reached:
					#	flash("Some search results have been omitted because the search took too long to perform.","alert-warning")

					return render_template('search.html',
						timeout_reached = timeout_reached,
						results=results,
						query=query,
						path=path,
						root_display_name = display_name,
						search_mode=True,
						browse_mode=False,
						browse_butts_enabled=False,
						bmark_enabled=False,
						url_home=url_for(func_name),
						crumbs=crumbs,
						on_file_click=bargate.lib.userdata.get_on_file_click())

				elif 'xhr' in request.args:

					## NORMAL BROWSE

					try:
						directory_entries = conn.listPath(share_name,path_without_share)
					except Exception as ex:
						return self.smb_error(ex)

					## Seperate out dirs and files into two lists
					dirs  = []
					files = []

					# sfile = shared file (smb.base.SharedFile)
					for sfile in directory_entries:
						entry = self._sfile_load(sfile, path, func_name)

						# Don't add hidden files
						if not entry['skip']:
							if entry['type'] == 'file':
								files.append(entry)
							elif entry['type'] == 'dir':
								dirs.append(entry)

					## Build a breadcrumbs trail ##
					crumbs = []
					parts  = path.split('/')
					b4     = ''

					## Build up a list of dicts, each dict representing a crumb
					for crumb in parts:
						if len(crumb) > 0:
							crumbs.append({'name': crumb, 'url': url_for(func_name,path=b4+crumb)})
							b4 = b4 + crumb + '/'

					## are there any items in the list?
					no_items = False
					if len(files) == 0 and len(dirs) == 0:
						no_items = True

					## What layout mode does the user want?
					layout = bargate.lib.userdata.get_layout()

					## Don't allow bookmarks at the root of a function
					## - that is superfluous
					bmark_enabled=False
					if len(path) > 0:
						bmark_enabled = True

					## Render the template
					return render_template('directory-' + layout + '.html',
						active=active,
						dirs=dirs,
						files=files,
						shares=[],
						crumbs=crumbs,
						path=path,
						url_home=url_for(func_name),
						url_bookmark=url_for('bookmarks'),
						url_search=url_for(func_name,path=path,action="search"),
						browse_mode=True,
						browse_butts_enabled=True,
						bmark_enabled=bmark_enabled,
						func_name = func_name,
						root_display_name = display_name,
						on_file_click=bargate.lib.userdata.get_on_file_click(),
						no_items = no_items,
					)
				else:
					return render_template('browse.html',path=path,browse_mode=True,url=url_for(func_name,path=path))

			else:
				abort(400)

		elif request.method == 'POST':
			###############################
			# POST: UPLOAD
			###############################
			if action == 'jsonupload':
				ret = []

				uploaded_files = request.files.getlist("files[]")
			
				for ufile in uploaded_files:
			
					if bargate.lib.core.banned_file(ufile.filename):
						ret.append({'name' : ufile.filename, 'error': 'Filetype not allowed'})
						continue
					
					## Make the filename "secure" - see http://flask.pocoo.org/docs/patterns/fileuploads/#uploading-files
					filename = bargate.lib.core.secure_filename(ufile.filename)
					upload_path = path_without_share + '/' + filename

					## Check the new file name is valid
					try:
						bargate.lib.core.check_name(filename)
					except ValueError as e:
						ret.append({'name' : ufile.filename, 'error': 'Filename not allowed'})
						continue
					
					file_already_exists = False
					try:
						sfile = conn.getAttributes(share_name,upload_path)
						file_already_exists = True
					except OperationFailure as ex:
						pass
					except Exception as ex:
						ret.append({'name' : ufile.filename, 'error': 'Could not check if file already exists: ' + str(type(ex))})
						continue

					byterange_start = 0
					if 'Content-Range' in request.headers:
						byterange_start = int(request.headers['Content-Range'].split(' ')[1].split('-')[0])
						app.logger.debug("Chunked file upload request: Content-Range sent with byte range start of " + str(byterange_start) + " with filename " + filename)

					# Check if we're writing from the start of the file
					if byterange_start == 0:
						## We're truncating an existing file, or creating a new file
						## If the file already exists, check to see if we should overwrite
						if file_already_exists:
							if not bargate.lib.userdata.get_overwrite_on_upload():
								ret.append({'name' : ufile.filename, 'error': 'File already exists. You can enable overwriting files in Settings.'})
								continue

							## Now ensure we're not trying to upload a file on top of a directory (can't do that!)
							if sfile.isDirectory:
								ret.append({'name' : ufile.filename, 'error': "That name already exists and is a directory"})
								continue

					# Upload
					try:
						if byterange_start == 0:
							conn.storeFile(share_name,upload_path, ufile, timeout=120)
						else:
							conn.storeFileFromOffset(share_name,upload_path, ufile, offset=byterange_start)

						ret.append({'name' : ufile.filename})
					except Exception as ex:
						app.logger.debug("Exception when uploading a file: " + str(type(ex)) + ": " + str(ex) + traceback.format_exc())
						## TODO... need better error handling here, but it means delving through OperationFailure error codes :(
						ret.append({'name' : ufile.filename, 'error': 'Could not upload file: ' + str(type(ex))})
						continue
					
				return jsonify({'files': ret})

			###############################
			# POST: RENAME
			###############################
			elif action == 'rename':
				try:
					old_name = request.form['old_name']
					new_name = request.form['new_name']
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'Invalid parameter(s)'})

				## Check the new file name is valid
				try:
					bargate.lib.core.check_name(new_name)
				except ValueError as e:
					return jsonify({'code': 1, 'msg': 'The new name is invalid'})

				## Build paths
				old_path = path_without_share + "/" + old_name
				new_path = path_without_share + "/" + new_name

				app.logger.debug("asked to rename from " + old_path + " to " + new_path)

				## Check existing file/directory exists
				try:
					sfile = conn.getAttributes(share_name,old_path)
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'Unable to read the existing entry'})

				if sfile.isDirectory:
					typestr = "directory"
				else:
					typestr = "file"

				try:
					conn.rename(share_name,old_path,new_path)
				except Exception as ex:
					app.logger.debug(ex)
					return jsonify({'code': 1, 'msg': 'Unable to rename: ' + str(type(ex))})
				else:
					app.logger.debug("Renamed from " + old_path + " to " + new_path)
					return jsonify({'code': 0, 'msg': "The " + typestr + " '" + old_name + "' was renamed to '" + new_name + "' successfully"})

			###############################
			# POST: COPY
			###############################
			elif action == 'copy':
				try:
					src  = request.form['src']
					dest = request.form['dest']
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'Invalid parameter(s)'})

				## check the proposed new name is valid
				try:
					bargate.lib.core.check_name(dest)
				except ValueError as e:
					return jsonify({'code': 1, 'msg': 'The new name is invalid'})

				## Build paths
				src_path  = path_without_share + "/" + src
				dest_path = path_without_share + "/" + dest

				app.logger.debug("asked to copy from " + src + " to " + dest)

				## Check if existing file exists
				try:
					sfile = conn.getAttributes(share_name,src_path)
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'The file you tried to copy does not exist'})

				if sfile.isDirectory:
					return jsonify({'code': 1, 'msg': 'Unable to copy a directory!'})

				## Make sure the new file does not exist
				try:
					sfile = conn.getAttributes(share_name,dest_path)
					return jsonify({'code': 1, 'msg': 'The destination filename already exists'})
				except:
					# could not get attributes, so file does not exist, so lets continue
					pass

				# read into a local temp file, because you can't 'open' a file handle
				# in pysmb, you have to read the entire thing and store it somewhere
				# oh and we need to reset the file pos 'cos storeFile expects that
				try:
					tfile = tempfile.SpooledTemporaryFile(max_size=1048576)
					conn.retrieveFile(share_name, src_path, tfile)
					tfile.seek(0)
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'Could not read from the source file'})

				try:
					conn.storeFile(share_name, dest_path, tfile, timeout=120)
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'Could not write to the new file'})


				return jsonify({'code': 0, 'msg': 'A copy of "' + src + '" was created as "' + dest + '"'})

			###############################
			# POST: MAKE DIRECTORY
			###############################
			elif action == 'mkdir':
				try:
					dirname = request.form['name']
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'Invalid parameter'})

				## check the proposed new name is valid
				try:
					bargate.lib.core.check_name(dirname)
				except ValueError as e:
					return jsonify({'code': 1, 'msg': 'That directory name is invalid'})

				try:
					conn.createDirectory(share_name,path_without_share + "/" + dirname)
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'The file server returned an error when asked to create the directory'})

				return jsonify({'code': 0, 'msg': "The folder '" + dirname + "' was created successfully."})

			###############################
			# POST: DELETE
			###############################
			elif action == 'delete':
				try:
					delete_name = request.form['name']
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'Invalid parameter'})

				delete_path  = path_without_share + "/" + delete_name

				try:
					sfile = conn.getAttributes(share_name,delete_path)
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'The file server returned an error when asked to check the file to be deleted'})

				if sfile.isDirectory:
					try:
						conn.deleteDirectory(share_name, delete_path)
					except Exception as ex:
						return jsonify({'code': 1, 'msg': 'The file server returned an error when asked to delete the directory'})

					return jsonify({'code': 0, 'msg': "The directory '" + delete_name + "' was deleted"})

				else:
					try:
						conn.deleteFiles(share_name, delete_path)
					except Exception as ex:
						return jsonify({'code': 1, 'msg': 'The file server returned an error when asked to delete the file'})

					return jsonify({'code': 0, 'msg': "The file '" + delete_name + "' was deleted"})

			###############################
			# POST: BOOKMARK
			###############################
			elif action == 'bookmark':

				try:
					bookmark_name     = request.form['name']
				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'Invalid parameter'})

				try:
					## Generate a unique identifier for this bookmark
					bookmark_id = uuid.uuid4().hex

					## Turn this into a redis key for the new bookmark
					redis_key = 'user:' + session['username'] + ':bookmark:' + bookmark_id

					## Store all the details of this bookmark in REDIS
					g.redis.hset(redis_key,'version','2')
					g.redis.hset(redis_key,'function', func_name)
					g.redis.hset(redis_key,'path',path)
					g.redis.hset(redis_key,'name',bookmark_name)

					## if we're on a custom server then we need to store the URL 
					## to that server otherwise the bookmark is useless.
					if func_name == 'custom':
						if 'custom_uri' in session:
							g.redis.hset(redis_key,'custom_uri',session['custom_uri'])
						else:
							return jsonify({'code': 1, 'msg': 'Invalid request'})

					## add the new bookmark name to the list of bookmarks for the user
					g.redis.sadd('user:' + session['username'] + ':bookmarks',bookmark_id)

					return jsonify({'code': 0, 'msg': 'Added bookmark ' + bookmark_name, 'url': url_for('bookmark',bookmark_id=bookmark_id)})

				except Exception as ex:
					return jsonify({'code': 1, 'msg': 'Could not save bookmark: ' + str(type(ex)) + " " + str(ex)})

			else:
				return jsonify({'code': 1, 'msg': "An invalid action was specified"})

	############################################################################

	def _init_search(self,conn,func_name,share_name,path,path_without_share,query):
		self.conn               = conn
		self.share_name         = share_name
		self.func_name          = func_name
		self.path               = path
		self.path_without_share = path_without_share
		self.query              = query

		self.timeout_reached = False
		self.results         = []

	def _search(self):
		self.timeout_at = int(time.time()) + app.config['SEARCH_TIMEOUT']
		self._rsearch(self.path,self.path_without_share)
		return self.results, self.timeout_reached

	def _rsearch(self,path,path_without_share):
		app.logger.info("rsearch " + path + " , " + path_without_share)
		try:
			directory_entries = self.conn.listPath(self.share_name,path_without_share)
		except Exception as ex:
			app.logger.debug("Search encountered an exception " + str(ex) + " " + str(type(ex)))
			return

		for sfile in directory_entries:
			## don't keep searching if we reach the timeout
			if self.timeout_reached:
				break;
			elif int(time.time()) >= self.timeout_at:
				self.timeout_reached = True
				break

			entry = self._sfile_load(sfile, path, self.func_name)

			## Skip hidden files
			if entry['skip']:
				continue

			if self.query.lower() in entry['name'].lower():
				entry['parent_path'] = path
				entry['parent_url'] = url_for(self.func_name,path=path)
				self.results.append(entry)

			## Search subdirectories if we found one
			if entry['type'] == 'dir':
				if len(path) > 0:
					sub_path = path + "/" + entry['name']
				else:
					sub_path = entry['name']

				if len(path_without_share) > 0:
					sub_path_without_share = path_without_share + "/" + entry['name']
				else:
					sub_path_without_share = entry['name']

				self._rsearch(sub_path, sub_path_without_share)


################################################################################

	def _sfile_load(self,sfile, path, func_name):
		"""Takes a smb SharedFile object and returns a dictionary with information
		about that SharedFile object. 
		"""
		app.logger.debug("_sfile_load " + sfile.filename + " " + path + " " + func_name)

		entry = {'skip': False, 'name': sfile.filename, 'size': sfile.file_size }

		## Skip entries for 'this dir' and 'parent dir'
		if entry['name'] == '.' or entry['name'] == '..':
			entry['skip'] = True

		## Build the path
		if len(path) == 0:
			entry['path'] = entry['name']
		else:
			entry['path'] = path + '/' + entry['name']

		## Hide hidden files if the user has selected to do so (the default)
		if not bargate.lib.userdata.get_show_hidden_files():
			## UNIX hidden files
			if entry['name'].startswith('.'):
				entry['skip'] = True

			## Office temporary files
			if entry['name'].startswith('~$'):
				entry['skip'] = True

			## Other horrible Windows files
			if entry['name'] in ['desktop.ini', '$RECYCLE.BIN', 'RECYCLER', 'Thumbs.db']:
				entry['skip'] = True

		if entry['skip']:
			return entry

		# Directories
		if sfile.isDirectory:
			entry['type'] = 'dir'
			entry['icon'] = 'fa fa-fw fa-folder'
			entry['stat'] = url_for(func_name,path=entry['path'],action='stat')
			entry['url']  = url_for(func_name,path=entry['path'])

		# Files
		else:
			entry['type'] = 'file'

			## Generate 'mtype', 'mtype_raw' and 'icon'
			entry['icon'] = 'fa fa-fw fa-file-text-o'
			(entry['mtype'],entry['mtype_raw']) = bargate.lib.mime.filename_to_mimetype(entry['name'])
			entry['icon'] = bargate.lib.mime.mimetype_to_icon(entry['mtype_raw'])

			## Generate URLs to this file
			entry['stat']         = url_for(func_name,path=entry['path'],action='stat')
			entry['download']     = url_for(func_name,path=entry['path'],action='download')
			entry['open']         = entry['download']

			# modification time (last write)
			entry['mtime_raw'] = sfile.last_write_time
			entry['mtime']     = bargate.lib.core.ut_to_string(sfile.last_write_time)

			## Image previews
			if app.config['IMAGE_PREVIEW'] and entry['mtype_raw'] in bargate.lib.mime.pillow_supported:
				if int(entry['size']) <= app.config['IMAGE_PREVIEW_MAX_SIZE']:
					entry['img_preview'] = url_for(func_name,path=entry['path'],action='preview')

			## View-in-browser download type
			if bargate.lib.mime.view_in_browser(entry['mtype_raw']):
				entry['view'] = url_for(func_name,path=entry['path'],action='view')
				entry['open'] = entry['view']

		return entry

